package heaptuple

import (
	"context"
	"fmt"
	"os"
	"testing"

	"github.com/jackc/pgx/v5"
	"github.com/stretchr/testify/assert"
)

var page Page

var data156 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

func TestTupleCnt(t *testing.T) {
	assert.Lenf(t, page.Slots, 4, "expected 4, got %d", len(page.Slots))
}

func TestSlotOffset(t *testing.T) {
	slotCnt := len(page.Slots)
	lastSlot := page.Slots[slotCnt-1]
	assert.EqualValues(t, lastSlot.GetTupleOffset(), page.Header.Upper)
}

func TestSlotLength(t *testing.T) {
	firstSlot := page.Slots[0]
	assert.Equal(t, firstSlot.GetTupleOffset()+firstSlot.GetTupleSize(), page.Header.Special)
}

// Nullbits map is generated by other fields, so just check it
func TestTupleHeader(t *testing.T) {
	firstTupleHeader := page.Tuples[0].Header
	notNullMapper := map[int]uint8{
		0: 1,
		1: 1,
	}
	for i := 0; i < 17; i++ {
		assert.Equal(t, firstTupleHeader.NullBits[i], notNullMapper[i])
	}

	secondTupleHeader := page.Tuples[1].Header
	notNullMapper = map[int]uint8{
		0:  1,
		1:  1,
		15: 1,
		16: 1,
	}
	for i := 0; i < 17; i++ {
		assert.Equal(t, secondTupleHeader.NullBits[i], notNullMapper[i])
	}

	thirdTupleHeader := page.Tuples[2].Header
	notNullMapper = map[int]uint8{
		0:  1,
		15: 1,
		16: 1,
	}
	for i := 0; i < 17; i++ {
		assert.Equal(t, thirdTupleHeader.NullBits[i], notNullMapper[i])
	}
	fourthTupleHeader := page.Tuples[3].Header
	notNullMapper = map[int]uint8{
		0:  1,
		15: 1,
		16: 1,
	}
	for i := 0; i < 17; i++ {
		assert.Equal(t, fourthTupleHeader.NullBits[i], notNullMapper[i])
	}
}

func TestTupleData(t *testing.T) {
	firstTupleData := page.Tuples[0].Data
	notNullMapper := map[string]string{
		"id": "1",
		"f1": "1",
	}
	for k, v := range firstTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}

	secondTupleData := page.Tuples[1].Data
	notNullMapper = map[string]string{
		"id":  "2",
		"f1":  "2",
		"f15": "ltx",
		"f16": "3",
	}
	for k, v := range secondTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}

	thirdTupleData := page.Tuples[2].Data
	notNullMapper = map[string]string{
		"id":  "3",
		"f15": "lq",
		"f16": "4",
	}
	for k, v := range thirdTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}

	foutrhTupleData := page.Tuples[3].Data
	notNullMapper = map[string]string{
		"id":  "4",
		"f15": data156,
		"f16": "4",
	}
	for k, v := range foutrhTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}
}

func TestMain(m *testing.M) {
	url := "postgres://localhost:8432/litianxiang"
	conn, err := pgx.Connect(context.Background(), url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)

	}
	defer conn.Close(context.Background())

	// test dataset !!!
	// conn.Exec(context.Background(), "DROP TABLE test;")
	// createSQL := `
	//  		CREATE TABLE test (
	//  			id serial,
	//  			f1 int,
	//  			f2 int,
	//  			f3 int,
	//  			f4 int,
	//  			f5 int,
	//  			f6 int,
	//  			f7 int,
	//  			f8 int,
	//  			f9 int,
	//  			f10 int,
	//  			f11 int,
	//  			f12 int,
	//  			f13 int,
	//  			f14 int,
	//  			f15 text,
	//  			f16 int
	//  		);
	//  		`
	// _, err = conn.Exec(context.Background(), createSQL)
	// if err != nil {
	// 	panic(err)
	// }

	// _, err = conn.Exec(context.Background(), `INSERT INTO test(f1) VALUES (1)`)
	// if err != nil {
	// 	panic(err)
	// }
	// _, err = conn.Exec(context.Background(), `INSERT INTO test(f1, f15, f16) VALUES (2, 'ltx', 3)`)
	// if err != nil {
	// 	panic(err)
	// }
	// _, err = conn.Exec(context.Background(), `INSERT INTO test(f15, f16) VALUES ('lq', 4)`)
	// if err != nil {
	// 	panic(err)
	// }
	// _, err = conn.Exec(context.Background(), fmt.Sprintf("INSERT INTO test(f15, f16) VALUES ('%s', 4)", data156))
	// if err != nil {
	// 	panic(err)
	// }

	// panic("for insert")

	var oid uint32
	row := conn.QueryRow(context.Background(), `SELECT oid FROM pg_class WHERE relname='test'`)
	err = row.Scan(&oid)
	if err != nil {
		panic(err)
	}

	err = conn.Close(context.Background())
	if err != nil {
		panic(err)
	}

	path := fmt.Sprintf("/home/litianxiang/usr/local/postgres/data/base/16384/%d", oid)
	p, err := ReadPage(path)
	if err != nil {
		panic(err)
	}
	page = p
	os.Exit(m.Run())
}

package heaptuple

import (
	"context"
	"fmt"
	"os"
	"testing"

	"github.com/krisdiano/pgdemo/heaptuple/testdata"

	"github.com/jackc/pgx/v5"
	"github.com/stretchr/testify/assert"
)

var (
	table Table
)

func TestHeapFileCnt(t *testing.T) {
	assert.Lenf(t, table.selfFiles, 1, "expected 1, got %d", len(table.selfFiles))
}

func TestToastHeapFileCnt(t *testing.T) {
	assert.Lenf(t, table.toastFiles, 1, "expected 1, got %d", len(table.toastFiles))
}

func TestPageCnt(t *testing.T) {
	var sum int
	for _, f := range table.selfFiles {
		sum += len(f.Pages)
	}
	assert.Equalf(t, sum, 1, "expected 1, got %d", sum)
}

func TestToastPageCnt(t *testing.T) {
	var sum int
	for _, f := range table.toastFiles {
		sum += len(f.Pages)
	}
	assert.Equalf(t, sum, 1, "expected 1, got %d", sum)
}

func TestTupleCnt(t *testing.T) {
	assert.Lenf(t, table.selfFiles[0].Pages[0].Slots, 6, "expected 6, got %d", len(table.selfFiles[0].Pages[0].Slots))
}

func TestSlotOffset(t *testing.T) {
	slotCnt := len(table.selfFiles[0].Pages[0].Slots)
	lastSlot := table.selfFiles[0].Pages[0].Slots[slotCnt-1]
	assert.EqualValues(t, lastSlot.GetTupleOffset(), table.selfFiles[0].Pages[0].Header.Upper)
}

func TestSlotLength(t *testing.T) {
	firstSlot := table.selfFiles[0].Pages[0].Slots[0]
	assert.Equal(t, firstSlot.GetTupleOffset()+firstSlot.GetTupleSize(), table.selfFiles[0].Pages[0].Header.Special)
}

// Nullbits map is generated by other fields, so just check it
func TestTupleHeader(t *testing.T) {
	firstTupleHeader := table.selfFiles[0].Pages[0].Tuples[0].Header
	notNullMapper := map[int]uint8{
		0: 1,
		1: 1,
	}
	for i := 0; i < 17; i++ {
		assert.Equal(t, firstTupleHeader.NullBits[i], notNullMapper[i])
	}
}

func TestTupleDataInt(t *testing.T) {
	secondTupleData := table.selfFiles[0].Pages[0].Tuples[1].Data
	notNullMapper := map[string]string{
		"id":  "2",
		"f1":  "2",
		"f15": "ltx",
		"f16": "3",
	}
	for k, v := range secondTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}
}

func TestTupleDataTextVarattrib1B(t *testing.T) {
	firstTupleData := table.selfFiles[0].Pages[0].Tuples[0].Data
	notNullMapper := map[string]string{
		"id": "1",
		"f1": "1",
	}
	for k, v := range firstTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}
}

func TestTupleDataTextVarattrib4BNoCompressed(t *testing.T) {
	foutrhTupleData := table.selfFiles[0].Pages[0].Tuples[3].Data
	notNullMapper := map[string]string{
		"id":  "4",
		"f15": testdata.Data156,
	}
	for k, v := range foutrhTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}
}

func TestTupleDataTextVarattrib4BCompressed(t *testing.T) {
	foutrhTupleData := table.selfFiles[0].Pages[0].Tuples[4].Data
	notNullMapper := map[string]string{
		"id":  "5",
		"f15": testdata.Data3120,
	}
	for k, v := range foutrhTupleData {
		gv, ok := notNullMapper[k]
		if !ok {
			assert.Equal(t, v, "NULL")
		} else {
			assert.Equal(t, v, gv)
		}
	}
}

func TestTupleDataTextToastOnDisk(t *testing.T) {
	tuples := table.GetTuples()
	for _, tpData := range tuples {
		if tpData["id"] != fmt.Sprintf("6") {
			continue
		}
		assert.Equal(t, tpData["f17"], testdata.Data3120)
		return
	}
	t.Fatalf("should reach here")
}

func TestMain(m *testing.M) {
	// PrepareDataPanic()

	t, err := NewTable("test")
	if err != nil {
		panic(err)
	}
	table = t

	os.Exit(m.Run())
}

// test dataset !!!
func PrepareDataPanic() {
	url := "postgres://localhost:8432/litianxiang"
	conn, err := pgx.Connect(context.Background(), url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)

	}
	defer conn.Close(context.Background())

	conn.Exec(context.Background(), "DROP TABLE test;")
	createSQL := `
	  		CREATE TABLE test (
	  			id serial,
	  			f1 int,
	  			f2 int,
	  			f3 int,
	  			f4 int,
	  			f5 int,
	  			f6 int,
	  			f7 int,
	  			f8 int,
	  			f9 int,
	  			f10 int,
	  			f11 int,
	  			f12 int,
	  			f13 int,
	  			f14 int,
	  			f15 text,
	  			f16 int,
	  			f17 text
	  		);
	  		`
	_, err = conn.Exec(context.Background(), createSQL)
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), `ALTER TABLE test ALTER f17 SET STORAGE EXTERNAL`)
	if err != nil {
		panic(err)
	}

	_, err = conn.Exec(context.Background(), `INSERT INTO test(f1) VALUES (1)`)
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), `INSERT INTO test(f1, f15, f16) VALUES (2, 'ltx', 3)`)
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), `INSERT INTO test(f15, f16) VALUES ('lq', 4)`)
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), fmt.Sprintf("INSERT INTO test(f15) VALUES ('%s')", testdata.Data156))
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), fmt.Sprintf("INSERT INTO test(f15) VALUES ('%s')", testdata.Data3120))
	if err != nil {
		panic(err)
	}
	_, err = conn.Exec(context.Background(), fmt.Sprintf("INSERT INTO test(f17) VALUES ('%s')", testdata.Data3120))
	if err != nil {
		panic(err)
	}

	panic("for insert")
}
